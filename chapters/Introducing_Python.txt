
# Introducing Python programming

Many textbooks on algorithms will present the algorithms in so-called *pseudo code*, something that looks like it is written in a real programming language while it is in fact written in an approximation to such a language but with the abstractions and programming constructs chosen to make the algorithm look as simple as necessary. Since the goal of this is to present the essentials of an algorithm and not distract the reader with unnecessary language artefacts, this is a sensible approach. It does, however, occasionally hide too many details from the reader, and since the pseudo code cannot actually be run by a computer, it is not possible to experiment with it to test different approaches to how an algorithm could be implemented in practice. In this book, we will not use pseudo code but present all algorithms in the Python programming language. Python is a very high-level language, and in many ways Python implementations of common algorithms look very similar to pseudo code versions of them, but with Python you get a working implementation.

Python is a complete general purpose programming language with many advanced features and it scales well to constructing very large software systems. At the same time, it has a very gentle learning curve and lets you implement small programs with very little programming overhead. It is perfect for our purpose in this book. By knowing just a small subset of the language you will be able to implement the algorithms we cover in the book and you will be able to experiment with them, and should you decide to make more of a career out of programming, then you can easily pick up the more advanced features of Python and use this language for larger projects as well.

Writing complete programs, especially larger applications, require different skills than the computational thinking this book is about. It takes a different skill set to be able to engineer software so it is scalable and maintainable than the skills that are needed to build efficient algorithms. Those software engineering skills are beyond the topic of this book, but if you find it interesting there are many excellent textbooks on the marked.

Even simpler programming tasks such as reading data from input files and formatting data for output files will be considered outside the scope of this book. If you ever need to write a program that can be used from a command line terminal, you will need to write code for input and output, but any introduction to Python programming textbook will teach you how to do this, and in many cases there will be existing software modules to assist you in this. This book, however, is not an introduction to Python programming book. We simply use Python to describe and experiment with algorithms we explore.

## Obtaining Python and Jupyter

When you write programs in Python, you will usually do this in one or more plain text files using a simple text editor. We will take a slightly different approach and use so-called *Jupyter notebooks* (but check the last section in the chapter if you want to go another way). Jupyter, [http://jupyter.org](http://jupyter.org), is a web interface to a text and code editor. Jupyter is not the ideal choice for large software projects—there you are better off with plain text Python files and perhaps an integrated development environment—but the Jupyter interface is frequently used when people do data analysis using Python. In the Jupyter interface, you can combine text, math, images, and tables with code that analyse your data and display the results of the analysis.

Jupyter isn't part of a standard Python installation---at least not yet---but the easiest way to install this interface is through a Python distribution that installs it and all the software it depends on. One such distribution is *Anaconda*. To download and install Anaconda, go to [https://www.anaconda.com/download](https://www.anaconda.com/download). There, you can download installation packages for Windows, OSX, and Linux. Download the distribution for your platform. The dialect of Python we will use in this book is Python 3.x (version numbers that start with 3). The differences between Python 2.x and 3.x for the purpose of the algorithms we will explore here are very minor, but you should download the installer for a Python 3.x version to get the version of Python we use here. Once you have downloaded the installer, double-click on it and follow the instructions guiding you through the installation for your platform.

The Anaconda installer will install Python, Jupyter, and various Python modules and frameworks for scientific computing, data analysis and visualisation. We only use a tiny fraction of the software that is installed via Anaconda, but everything we do use will be available to you once you have installed Anaconda. If you continue programming in Python after you have read this book, chances are that you will find good use for many of the other modules installed by Anaconda.

## Starting Jupyter and creating a notebook

Once you have installed Jupyter, you can start the web-server you will interact with when working in Jupyter notebooks. In a terminal, write:

```sh
jupyter notebook
```

and hit Enter. The result will be similar to that seen in [@fig:running-jupyter].

![Running Jupyter.](figures/running-jupyter){#fig:running-jupyter}

Starting up Jupyter should also open your web-browser with a window showing the directory in which you started Jupyter. I started the server in an empty directory, and my browser opened up looking like in [@fig:empty-jupyter].

![Jupyter opened in an empty directory.](figures/empty-jupyter){#fig:empty-jupyter}

If you click the *New* button in the upper right corner, you can create a new file in this directory. You have several choices here, but we will always go with a Python 3 Notebook, see [@fig:new-jupyter-notebook].

![Creating a new notebook.](figures/new-jupyter-notebook){#fig:new-jupyter-notebook}

The new notebook you create this way will open up. At the top of the page, you will see that it is named "Untitled", see [@fig:untitled-jupyter-notebook]. You can click on the title and rename the notebook, see [@fig:renaming-jupyter-notebook].

![Untitled new notebook.](figures/untitled-jupyter-notebook){#fig:untitled-jupyter-notebook}

![Renaming the new notebook.](figures/renaming-jupyter-notebook){#fig:renaming-jupyter-notebook}

Below the menu and tool bar in the notebook you have the notebook proper. A notebook consists of one or more "cells". In the new notebook we just created there is a single cell. That is the box with "In [ ]: " in front of a field where you can type. Cells come in different types; you can go to the "Cell" menu and then select "Cell Type" to see the options. In the exercises associated with this book we will only use two types: Markdown and Code. Markdown cells are text cells; we use these to write prose. Markdown is a language for marking up text (the name is a pun on "mark up"), so we can make text italic or bold and we can format text into lists and such. The code cells contain Python code. Markdown cells are just text until you double click on them; when you do, you can edit the text. Code cells have "In [ ]: " in front of them and you can edit code in the grey area inside them. The "In [ ]: " is a prompt and a leftover from the IPython program that Jupyter is a descendant of.

Tradition has it, that the first program you write in any new Programming language is one that prints "hello, world!". Type the following into the code cell in your notebook:

```python
print("hello, world!")
```

You can then evaluate it. You can do this by hitting the "play" button in the tool bar, by selecting "Run Cells" in the "Cell" menu, or by pressing Shift-Enter. When you evaluate the cell, the result of the evaluation will be shown below the input part of the cell and a new cell will be created below, see [@fig:hello-world-jupyter-notebook].

!["Hello, world" in a notebook.](figures/hello-world-jupyter-notebook){#fig:hello-world-jupyter-notebook}

When you evaluate the cell, you will notice that "In [ ]: " changes to "In [1]: ". The number here, one, indicates that it is the first cell you evaluated. The cells in a notebook are evaluated when you explicitly choose to evaluate them, and each time a cell is evaluated the number is increased. You can see, from the numbers to the left of the code input, the order in which cells have been evaluated.

This isn't really ideal. You would expect code to be evaluated in the order you read it, so from top and down. This isn't how Jupyter does it, though; you have to explicitly evaluate cells you want evaluated (which is probably a good thing since you don't have to evaluate cells that are not modified and might take a while to run) and you can do this in any order you want (which is probably a bit risky since it doesn't take into account possible dependencies between the cells).

If the dependencies and order in which you evaluate cells start to confuse you, you can restart the notebook and reevaluate all the cells in order. Just go to the "Kernel" menu and select "Restart & Run All".

When you evaluate a cell, any output you print will be shown below the input code. In addition, unless the last expression in a cell evaluate to `None`, a special value in Python that indicate nothingness, the result of the final expression will also be printed. In the "hello, world!", example above, the last (and only) expression was the `print` command, and this command returns `None`, so no value was printed. The "hello, world!" that was printed in the cell was the side effect of printing; it wasn't the *result* of the print expression. To see the difference, try putting just the string `"hello, world!"` in the next cell and evaluate it (see [@fig:hello-world-jupyter-notebook-2]).

!["Hello, world", printing and evaluating.](figures/hello-world-jupyter-notebook-2){#fig:hello-world-jupyter-notebook-2}

The result appear similar to the print cell, but you have "Out[2]: " to the left of the `"hello, world!"` output, and that output is in quotes. The "Out[2]: " tells us that this is the result we get from evaluating the cell (the number is the same as the "In[2]: " number the cell got when we evaluated it). The string `"hello, world!"` is an expression that evaluates to the string itself, and because this string is not `None`, Jupyter displays it.

We will not make much of a distinction between printing values or displaying them by default when they are the result of the last expression in a cell we evaluate, but when you are working with code in a notebook, you might find it helpful to simply evaluate expressions in cells and see what Python thinks the look like.

## Using a Jupyter Notebook

The simplest way you can use Python is as a calculator. You can write arithmetic expressions in a code cell and evaluate it to get the result.

Create a new notebook. This will open a new page with a single cell. Put

```python
2 + 2
```

into that cell and then press Shift-Enter You should get

    4

below the cell, and a new cell after that. In that cell, try typing

```python
3 * 5
```

and press Shift-Enter again. This time you should get

    15

below the cell.

If you go back to the first cell and change the expression to

```python
2 + 4
```

instead, and press Shift-Enter. Now you should see the output change to 6 and the focus will be on the second cell. If you go back to the first cell again and press Alt-Enter instead, you also get 6 as the answer to the expression, but you will also insert a new cell below the answer. The difference between using Shift-Enter and Alt-Enter is that the former only evaluate a cell while the latter inserts a new cell below the answer.

There are different kinds of cells in a Notebook. The ones you have right now are *code cells*. These are the cells you use to write Python commands in. The other two types are *Markdown* and *Raw NBConvert*. You can change the type of a cell by going to the **Cell** menu, pick the **Cell Type** sub-menu, and then the type you want.

The *Raw NBConvert* type has a weird name, but it is a cell type that just lets you write raw text. You can try to make a new cell and change the type to *Raw NBConvert* and write something in it. If you evaluate the cell, Jupyter will just leave it as it is.

The *Markdown* cell type also lets you write text, as opposed to code, but in this cell type you can get the text formatted. Markdown is a markup language—the name Markdown is a pun based on markup—which means that it is text where a few special characters lets you modify how the text is displayed. For example, if you put `*` before and after a word, that word will be displayed as italic, while if you put `**` before and after a word, that word will be shown in boldface. 

Try creating a Markdown cell and write

	This is *a* **very** important text.

into it and evaluate the cell. The result is just the text you wrote, but with `a` in italic and `very` in boldface.

Markdown has nothing to do with Python, and we will not use it much in this book. It is used in Notebooks because it allows you to document what you are doing interleaved with the code you actually execute when you are solving a problem.

This chapter is focused on the Python programming language, so you don’t need to worry about Markdown for most of it. You can live a happy life as a Python programmer without ever using Markdown, or Jupyter Notebooks, for that matter. Most Python programmers do not use either. If you write programs that people can call on a command line, or if you write software packages that can be reused in multiple projects, you will not use Notebooks. The purpose of Notebooks is to have self-contained documents that describe an analysis and contain the code used in that analysis. Notebooks are very useful for data analysis; if you want to develop reusable software instead, you will not use Notebooks. Notebooks are for data scientists doing data analysis, not so much for programmers developing new software.

I have chosen to use Jupyter in this book under the assumption that most readers will be interested in using programming to solve problems that they run into while working on a scientific problem—where “scientific” should be considered in a very broad sense. Programming is useful for anyone who has to analyse data of any substantial size, in natural sciences, statistics, economics, social sciences—whenever you have problems of a quantitative nature. Most people that program these days use programming to solve problems in their own field. It is no longer the domain of computer scientists alone. If you are a data scientist, that is, you need to manipulate data and compute on it to solve problems in your own domain of work, then using Notebooks is most likely the best approach. So it is a good place to start, if you are new to programming, and I have made all the programming exercises available as Jupyter Notebooks that you can download and use to do the exercises in.

Towards the end of the book, I will briefly cover a few topics for when you want to reuse code in multiple projects, of when you want to distribute your code for others to use. You might never find the need for this, but if you do, it is covered at the end of the book.

Before you start worrying about packaging up software and writing larger programs, though, you need to get familiar with programming, and in the following sections I will give you a quick introduction to how to program in Python. I will only cover the very basics, and leave some programming topics for later chapters.

## Expressions in Python

We have already seen how we can evaluate simple arithmetic expressions in Python. The arithmetic binary operators `+`, `-`, `*` and `/`, works as you would expect them to, as does the unary `-`. That is,

```python
-4
```

is minus four, 

```python
2 * 2 + 3
```

is seven. Notice that we interpret `2 * 2 + 3` as you are familiar with in mathematical notation. First we multiply two by two and then you add three. This is not because we evaluate the expression left-to-right, in which case

```python
3 + 2 * 2
```

would mean $(3 + 2) * 2$ and would be 10. It is because multiplication “binds tighter” or “has larger precedence” than addition. This is also what you are familiar with. In mathematical notation, you would expect $3 + 2\cdot 2$ to be seven and not ten. Multiplication and division binds tighter than addition and subtraction.

When precedence is taken into account, the evaluation does proceed from left to right. For example, 

```python 
1 / 2 / 2
```

is interpret as $(1/2)/2=1/4$ and not $1/(2/2)=1$. To get the latter interpretation you will need to add parentheses:

```python
1 / (2 / 2)
```

You can always use parentheses to change the default evaluation order. Or just to make explicit what you intend, even if it is already the default. Writing `(2 * 2) + 3`, while it is the default for `2 * 2 + 3`, doesn’t make the expression any harder to read, after all.

There are more operations that addition, subtraction, multiplication, and divisions. For example, raising a number to a power. If you want to compute two to the power of four, $2^4=16$, you can use the `**` operator: `2**4`. This operator has higher precedence than multiplication and division, so `2 * 2**4` is $2\cdot 2^4=32$ and not $(2\cdot 2)^4=256$. This operator is not evaluated left-to-right but right-to-left, also in accordance with typical mathematical notation. This means that `2**3**4` is interpreted as $2^{3^4}\approx 2.4\times 10^{24}$ and not $(2^3)^4=4086$. If you want to compute the latter, you must write `(2**3)**4`. The notation is the same as it would be in mathematics, but if you find it hard to remember, you can always use parentheses even when not strictly necessary to avoid any surprises.

Python actually has two different division operators. When you use `/` you get the division you are used to in mathematics. However, it is often useful to guarantee that if you divide two numbers you get the integer result of the division. Remember that for division, $n/m$, you get an integer if $m$ divides $n$. You can write $n=a\cdot m + b$ where $a$ is the integer number of times that $m$ divides $n$ and $b<m$ is the remainder. To get the integer part of the division, $a$ in this example, you will use the `//` operator. So while `5 / 2` will give you 2.5, `5 // 2` will give you 2. To get the remainder, you use the modulus operator, `%`. Since $5=2\cdot 2 + 1$, we would expect `5 % 2` to be one, and indeed it is. If you evaluate

```python
(5 // 2) * 2 + (5 % 2)
```

the $a\cdot m + b$ form of this division, you get five, as expected. Another way to put this is that `5 // 2` is five divided by two, rounded down, or $\lceil 5/2 \rceil$.

**Exercises:** Evaluate the following expressions in Python. Check that they give you the expected result. If not, check if you can change that by inserting parentheses.

1. $2\cdot 4 + 2$
2. $2^4 - 4^2$
3. $2\cdot(1+2+3)$
4. $5/2$
5. $\lceil 5/2\rceil$
6. $\frac{2}{1+2+3}$
7. $\frac{1+2+3}/2$

### Logical (or boolean) expressions

There are other kinds of expressions, some of which you might be less familiar with. One such kind is logical, also known as boolean, expressions. Those are expressions that has a true or false result rather than a numerical result. In Python, true and false are written `True` and `False`. Notice that these are capitalised. It is not `true` and `false` but `True` and `False`.

You are familiar with the most common logical expressions: $a=b$, $a\neq b$, $a<b$, $a\leq b$, $a>b$, $a\geq b$, which in Python are written as, in the same order: `a == b`, `a != b`, `a < b`, `a <= b`, `a > b`, `a >= b`. Notice that equality is written with two equality signs. If you write `a = b` instead of `a == b` you are not comparing `a` and `b`, but rather assigning `b` to `a`, as we shall see below. If both `a` and `b` are numbers, you will get an error if you use a single equality sign. When we start using variables, you will not get any error, but you will not be comparing two values.

You can string these comparisons together, so if you want to say that `b` is between `a` and `c`, you can write `a < b < c`. You don’t need to write such comparisons low-to-high, as above, or high-to-low as in `c > b > a`, but use any sequence of comparisons, e.g. `a > b < c` to say that `b` should be less than both `a` and `c`, without making any claims about the order of `a` and `c`.

I mentioned above that something like `2 = 1 + 1` would be an error—to compare two versus one plus one you need to write `2 == 1 + 1`. Try evaluating the first of these expressions in a Notebook cell and see the result. You should get an error message that says

```pythong
SyntaxError: can't assign to literal
```

There are many ways that you can get an error in Python, when you are doing something Python doesn’t understand, and a `SyntaxError` is what you get when you write an expression that Python cannot interpret as a valid expression. When you get an error, Python will tell you what it is that it doesn’t understand, but unfortunately it isn’t always easy to see what the error is from the message you get. Since we haven’t covered assignments yet—we will shortly—this might be one of those cases. With experience, it gets easier to understand the error messages.

Other logical operators you will be familiar with if you are familiar with basic logic, but might not be otherwise. The logical operators that Python supports are logical-not ($\neg$), logical-and ($\land$), and logical-or ($\lor$). Python does not support operator logical-xor.

Logical-and of two expressions, written as `and` in Python, is `True` if and only if both expressions are true. For example,

```python
2 == 1 + 1 and 3 == 2 + 1
```

evaluates to `True`, while

```python
2 == 1 + 1 and 3 == 2
```

and 

```python
2 == 1 and 3 == 2 + 1
```

will be `False`.

In these expressions you can see that we mix arithmetic and logical operators. When you do this, the arithmetic operators bind tighter than the logical ones, and the comparisons bind tighter than `and` (as well as logical-or and logical-xor), so

```python
2 == 1 + 1 and 3 == 2 + 1
```

means 

```python
(2 == (1 + 1)) and (3 == (2 + 1))
```

and not, for example,

```python
((2 == 1) + 1) and ((3 == 2) + 1)
```

As with arithmetic operators, you can use parentheses to change the default order the operators are evaluated in. The expressions above are all valid Python expressions, they just mean different things. If you wonder how you can possibly add 1 to the comparison `2 == 1` above, you are right to wonder. Usually, it doesn’t make sense to add a logical value to a number. In many programming languages, however, you are allowed to, and then `False` is interpreted as zero and `True` as one. So, while

```python
2 == 1 + 1
```

is `True`, 

```python
(2 == 1 + 1) + 1
```

is one because `(2 == 1 + 1)` evaluates to `True` that, when we add one to it, is interpreted as one. Likewise, 

```python
(2 == 1) + 1
```

will be one, since `(2 == 1)` is `False`, which is interpreted as zero.

Logical-or, written `a or b`, is true if either or both `a` and `b` are `True`. So all of the expressions below evaluate to `True`

```python
2 == 1 + 1 or 3 == 1 + 2
2 == 1 or 3 == 1 + 2
2 == 1 + 1 or 3 == 1
```

but 

```python
2 == 1 or 3 == 1
```

will be `False` since both `2 == 1` and `3 == 1` are `False`.

Logical-exclusive-or, or logical-xor, is true if either, but not both, expressions are `True`. Python does have an xor operator, `^`, but it doesn’t work as logical-xor. If you give it operands that are numbers, you will get numbers back. For example, if you write 

```python
3 ^ 1
```

your result will the result 2—I will explain why in the next section. For the xor-operator to behave like the logical operator, you need to make sure that both its operands are boolean values. You can do this by wrapping expressions in parentheses. If you do this, then expression two and three below will be `True` while one and four will be `False`.

```python
(2 == 1 + 1) ^ (3 == 1 + 2)
(2 == 1) ^ (3 == 1 + 2)
(2 == 1 + 1) ^ (3 == 1)
(2 == 1) ^ (3 == 1)
```

The first expression is false because both inputs to the operator are true—and xor is only true if one of them is. The fourth expression is false because both operands are false.

### Bit-wise expressions

All data on a computer are ultimately represented as binary, zeros and ones. We call a single such value a *bit*, and any number or logical value, obviously, has to be stored as a sequence of bits. A logical value can be represented by a single bit while numbers must be represented by more bits. Python doesn’t *actually* use a single bit for `True` and `False`—it is less efficient to do so on a modern computer, but you need to worry about that. You very rarely need to worry about the binary representation of data in general. If you have two numbers, though, they will have binary representations, and you can interpret them as sequences of bits and manipulate those bits. We will see a few uses of this later in the book, but it is not essential to understand bit manipulations for the majority of the book, so you can safely skip this section and later sections where we manipulate numbers at the bit level.

If you are interested in bit-wise operators, however, all you need to know is that we have the same operators as the logical ones, they just operate on individual bits in your numbers.

The binary representation of numbers are the base-two representation. For example, the decimal numbers below have the corresponding binary representations:

* $0_{10} = 00_2$
* $1_{10} = 01_2$
* $2_{10} = 10_2$
* $3_{10} = 11_2$

For the binary numbers I have used a leading zero when the numbers are smaller than two. This is because, when we manipulate bits, we want to include all the bits in a number. A number is never represented by just two bits. The minimal number of bits used in an integer depends on your computer, but Python can use an arbitrary number of bits to represent integers of arbitrary size. I use two bits above just for the example. You can get the binary representation of any integer,[^binary_floating_point] `a`, by writing `bin(a)`, but it will not give you leading zeros. You can try to translate the four integers above into binary using

[^binary_floating_point]: A computer cannot represent real numbers in general, since these often require an infinite number of decimals or bits. Instead, it approximates these using what is known as *floating point* numbers. It essentially maps real numbers into a finite set of numbers. If you write `1.5` in Python, you have a floating point number. You cannot use `bin(1.5)` to get the binary representation of the floating point number. We usually do not manipulate the bits in a floating point number, so this is not a limitation you should worry about.

```python
bin(0)
bin(1)
bin(2)
bin(3)
```

The results of these are strings—see next section if you wonder what those are—and they all start with `0b`. You will notice that the results are put in single-quotes, `'0b0'`, `'0b1'`, `'0b10'` and `'0b11'`. This means they are strings.

You cannot prefix a decimal number by zero. Python considers it an error if you try to represent eighth as `08`. You can, of course, write zero with a leading zero, and you can write any number of zeros then, but otherwise it is an error. This is because a convention in some programming languages is that a leading zero means that the number you are writing is octal, i.e., base eight. Python also did that in older versions. In octal, the number $10_8$ is $8_{10}$, not ten. You don’t want to write a number in octal by mistake, so Python doesn’t allow you to do that. In earlier versions of Python, writing `010` would be a valid input that means eight. It would be different from `10`, but you would not get any warning that you might have input the wrong number. Python doesn’t implicitly make numbers octal like this any more, so you get an error instead. If you want to input a number in octal, you should prefix it with `0o`, so you can write `0o10` to mean eight. Python also lets you input numbers in hexadecimal, i.e., base 16. For that, you should use the prefix `0x`, so `0x10` is 16.

The prefix `0b` states that the following number is in binary. You can also translate a binary number into a decimal number in Python by prefixing the number with `0b`. If you do this, though, you should not put the number in quotes. If you evaluate

```python
0b00
0b01
0b10
0b11
```

you get the numbers zero to three.

Now, the bit-wise operators work like the logical operators, they just do so bit-wise. The bit-wise and of `0b10` and `0b11` will be `0b10`—the first bit is 1 in both numbers, so that becomes 1 in the result; the second bit is only 1 in the second number, so the second bit in the output will be zero. You do not use `and` and `or` for bit-wise operators.

The bit-wise *and* operator is written `&`. Try evaluating

```python
bin(0b10 & 0b11)
```

You will see that the result is the string `'0b10'`. It is only a string because of `bin`, if you only evaluate `0b10 & 0b11` you get 2, which is the same as `0b10`.

The bit-wise *or* operator is written `|`. If you write

```python
bin(0b10 | 0b11)
```

you get `'0b11'`. Both bits are one because `1 | 1 == 1` and `0 | 1 == 1`.

I mentioned the exclusive-or, written `^`, above. We already saw how it works on logical expressions, but it is actually a bit-wise operator. If you write

```python
3 ^ 1
```

you are actually evaluating the bit-wise xor 

```python
0b11 ^ 0b01
```

which is `0b10 == 3`.

If you use the logical operators on numbers you get numbers back, but they behave differently. An `and` operator will return zero if the first operand is zero and otherwise return the second operand. An `or` operator will return the first operand if non-zero and otherwise the second.

**Exercise:** Why do you think the logical operators work this way on numbers?

## Working with strings

**FIXME: here**

## Printing and formatting output


```python

```

## Statements and variables

## Conditional statements

## Loops

## A quick guide to Markdown and Literate Programming

## I don’t want to use a fancy Notebook, what can I do?