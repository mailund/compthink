# Conclusions

Well, that’s it. You have reached the end of the book. But I hope you haven’t reached the end of your programming and algorithmic career.

The techniques we have covered in this book should give you a better understanding of how a computer stores and manipulate data, and how different choices in how you implement this will affect the performance of programs you write. We have used Python to implement the algorithms we have explored, but the techniques are general. Built in data structures will vary between different programming languages, and different software libraries will provide alternative algorithms and data structures, but you should now be able to understand the tradeoffs when choosing between alternatives.

Most commonly used algorithms and data structures will be available in any high-level programming language environment, so you will rarely need to implement them yourself. Knowing the pros of cons of different choices, however, is essential for using your programming environment effectively, and this knowledge is likely to be the most important lessons you can take from this book. When you cannot use algorithms and data structures readily available in your programming environment, you now also have the skills to adapt them to your needs, and when necessary, to implement alternatives that better suits your needs.

Python is a very high-level programming language, and it has many powerful features that makes programming in it more effective. I have not used those constructions in this book, where they are not strictly needed, so what you have learned here can most likely be directly translated to other programming languages, if needed. That being said, different programming languages have idiomatic ways of solving problems. If you learn a new programming language, it is worthwhile to learn these idioms. You shouldn’t simply use the constructions from Python in a different language. If you simply use the language constructions you know from Python, you can write programs in other languages, but you will be using only the subset of constructions common to both Python and other languages, and that is not the most effective approach. It is always worthwhile to know the idioms in the language you are using. Since this book is primarily about computing and algorithmic thinking, I have used the simplest constructions in Python that will get the job done, but if you want to become an effective Python programmer, you should spend some time learning the more advanced features you have in the language. Likewise, if you want to be an effective R or Ruby programmer, you should learn the idiomatic ways of solving problems in those languages. The computational issues you need to deal with, however, will be the same.

Python is not a particular fast language, by which I mean that Python programs are likely to run slower than similar programs in more low-level languages. As a general rule of thumb, this is usually the case; programs written in a high-level language are likely to run slower than programs written in a low-level language. This isn’t always the case, and depends strongly on the interpreter or compiler you use, but is often the case. If you want complete control of how your programs are executed so you can get the utmost performance out of your computer, you will need to program in a very low-level language—close to the iron, as we say. This, however, is usually not an effective way to solve problems. Programs written in a low-level language might run faster, but it comes at a cost in programmer time—programs written in a high-level language are much faster to write. There is always a trade-off between programmer efficiency and program efficiency, and optimising at a low level is rarely worth the effort. Sometimes it is worthwhile to optimise key hotspots in a program by rewriting those parts in a lower level language, but choosing the right algorithms and the right data structures is much more important. A low-level implementation of a slow algorithm is always going to be outperformed by a smarter algorithm implemented in a high-level language when you work with large data. You now have the skills to evaluate algorithms and to choose the best for your tasks. That is much more important than the skills to program in a low-level language.


## Where to go from here

After reading this book, you should be familiar with basic programming, you should be able to construct and reason about algorithms, and have some understanding of how a computer represents and manipulate data. These are the cornerstones of writing efficient programs and effectively analyse data. There is much more to learn to use computers and Python optimally, however.

The next step you should take in becoming a better programmer or data scientist depends on what you wish to achieve in your future use of Python. If you have gotten a taste for programming and want to start developing software, you should pick up some books on Python programming. I have only covered the aspects of Python that I needed to teach you about algorithms and data structures. There are many features in Python aimed at making your programming more effective or aimed at making your software more reusable. At the very least, you should learn about object-oriented programming and how classes and objects can be used to develop software that can be extended to solve many more problems than it was originally developed for.

If your aim is to get into heavy-duty scientific programming, you will need to study some numerical analysis, so you understand the issues you might run into when working with floating point numbers. You will also want to get familiar with working with linear algebra and possibly tensors. Your next step should almost certainly be to get familiar with `numpy` and `scipy`.

If you would rather learn more about data science in Python, your next step should be learning about the `pandas` package. This is a Python package for manipulating and analysing structured data of the kind you will usually run into in data analysis projects.

If you want to get into machine learning, then `scikit-learn` and `tensorflow` are good places to start. After that, you might want to study the `keras` package, which is a very efficient implementation of *deep-learning neural networks*, a technology used in many high-profile artificial intelligence projects.

If you are more interested in learning more about algorithms and computational complexity, you should instead find some text books on those topics. There are many good ones that covers topics beyond what we have covered in this book, but they are typically not based on Python. Most general algorithmic books are language agnostic and use pseudocode instead of real programming languages.

There are many places to go from here, and those are some of the directions you might want to go in if you want to learn more about computing and Python.

I will just end the book by wishing you good luck, and if you have found the book useful I would love to hear from you.
